--
-- For use with https://github.com/supabase/supabase/tree/master/examples/slack-clone/nextjs-slack-clone

-- Custom types
create type public.app_permission as enum ('advertisers.delete', 'campaigns.delete');
create type public.app_role as enum ('admin', 'moderator', 'anonymous');
create type public.campaign_status as enum ('draft', 'active', 'paused', 'completed');
create type public.ad_status as enum ('active', 'paused', 'inactive');
create type public.interaction_type as enum ('impression', 'click');

-- USERS
create table public.users (
  id          uuid not null primary key, -- UUID from auth.users
  username    text
);
comment on table public.users is 'Profile data for each user.';
comment on column public.users.id is 'References the internal Supabase Auth user.';

-- Advertiser Table 
create table public.advertisers (
  id            bigint generated by default as identity primary key,
  created_at    timestamptz default now() not null,
  created_by    uuid references public.users not null,
  name          varchar(32) not null unique,
  description   varchar(128)
);
comment on table public.advertisers is 'A company or a person that runs advertisements.';

create table public.user_advertisers (
    user_id uuid references public.users on delete cascade,
    advertiser_id bigint references public.advertisers on delete cascade,
    primary key (user_id, advertiser_id)
);
comment on table public.user_advertisers is 'A user-advertiser mapping table.';

-- Campaign Table
create table public.campaigns (
  id              bigint generated by default as identity primary key,
  created_at      timestamptz default now() not null,
  updated_at      timestamptz default now() not null,
  created_by      uuid references public.users not null,
  name            varchar(64) not null,
  budget          bigint not null check (budget >= 0), 
  start_date      timestamptz not null,
  end_date        timestamptz not null check (end_date >= start_date), 
  status          campaign_status default 'draft' not null,
  advertiser_id   bigint references public.advertisers on delete cascade not null
);
comment on table public.campaigns is 'Information about advertising campaigns.';

-- Ad Table
create table public.ads (
  id                bigint generated by default as identity primary key,
  campaign_id       bigint references public.campaigns on delete cascade not null, 
  title             varchar(64) not null,
  description       varchar(128),
  image_url         text,
  landing_page_url  text not null,
  status            ad_status default 'active' not null,
  created_at        timestamptz default now() not null,
  updated_at        timestamptz default now() not null,
  created_by        uuid references public.users not null
);
comment on table public.ads is 'Advertisements running on a campaign.';

-- Impression Log Table
create table public.ad_interactions (
  id            bigint generated by default as identity primary key,
  ad_id         bigint references public.ads, 
  user_id       uuid references public.users,
  timestamp     timestamptz default now() not null,
  status        interaction_type default 'impression' not null
);
comment on table public.ad_interactions is 'Record every instance where an ad is displayed to a user';

-- USER ROLES
create table public.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references public.users on delete cascade not null,
  role      app_role not null,
  unique (user_id, role)
);
comment on table public.user_roles is 'Application roles for each user.';

-- ROLE PERMISSIONS
create table public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';

-- authorize with role-based access control (RBAC)
create function public.authorize(
  requested_permission app_permission,
  user_id uuid
)
returns boolean as
$$
  declare
    bind_permissions int;
  begin
    select
      count(*)
    from public.role_permissions
    inner join public.user_roles on role_permissions.role = user_roles.role
    where
      role_permissions.permission = authorize.requested_permission and
      user_roles.user_id = authorize.user_id
    into bind_permissions;

    return bind_permissions > 0;
  end;
$$
language plpgsql security definer;

-- Secure the tables
alter table public.users
  enable row level security;
alter table public.advertisers
  enable row level security;
alter table public.user_advertisers
  enable row level security;
alter table public.campaigns
  enable row level security;
alter table public.ads
  enable row level security;
alter table public.ad_interactions
  enable row level security;
alter table public.user_roles
  enable row level security;
alter table public.role_permissions
  enable row level security;

-- inserts a row into public.users and assigns roles
create function public.handle_new_user()
returns trigger
set search_path = ''
as $$
  declare is_admin boolean;
  begin
    insert into public.users (id, username)
    values (new.id, new.email);

    select count(*) = 1 from auth.users into is_admin;

    if position('+supaadmin@' in new.email) > 0 then
      insert into public.user_roles (user_id, role) values (new.id, 'admin');
    elsif position('+supamod@' in new.email) > 0 then
      insert into public.user_roles (user_id, role) values (new.id, 'moderator');
    end if;

    return new;
  end;
$$ language plpgsql security definer;

-- trigger the function every time a user is created
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

create or replace function is_user_authorized_for_advertiser(user_id uuid, advertiser_id bigint)
returns boolean as
$$
  begin
    return exists (
      select 1 from user_advertisers
      where user_advertisers.user_id = is_user_authorized_for_advertiser.user_id
      and user_advertisers.advertiser_id = is_user_authorized_for_advertiser.advertiser_id
    );
  end;
$$ language plpgsql security definer;

create policy "Allow logged-in read access" on public.users
  for select using (auth.role() = 'authenticated');
create policy "Allow individual insert access" on public.users
  for insert with check ((select auth.uid()) = id);
create policy "Allow individual update access" on public.users
  for update using ( (select auth.uid()) = id );

CREATE POLICY "Allow users to view only their advertisers"
ON public.user_advertisers
FOR SELECT
USING (user_id = auth.uid());

CREATE POLICY "Prevent users from manually inserting mappings"
ON public.user_advertisers
FOR INSERT
WITH CHECK (false);

CREATE POLICY "Prevent users from updating mappings"
ON public.user_advertisers
FOR UPDATE
USING (false);

CREATE POLICY "Enable delete for users based on user_id"
ON public.user_advertisers
FOR DELEtE
USING ((select auth.uid()) = user_id);


create policy "User can access only their advertisers" on public.advertisers
  for select using (is_user_authorized_for_advertiser((select auth.uid()), id));

-- Allow only authenticated users to insert new advertisers
CREATE POLICY "Enable insert for authenticated users only"
ON public.advertisers
FOR INSERT
TO authenticated
WITH CHECK (true);

-- Allow users to update only advertisers they are mapped to
CREATE POLICY "Allow users to update their advertisers"
ON public.advertisers
FOR UPDATE
USING (is_user_authorized_for_advertiser((select auth.uid()), id));

CREATE POLICY "Allow users to delete their advertisers"
ON public.advertisers
FOR DELETE
USING (is_user_authorized_for_advertiser((select auth.uid()), id));

CREATE OR REPLACE FUNCTION add_user_advertiser_mapping()
RETURNS TRIGGER AS
$$
BEGIN
  INSERT INTO user_advertisers (user_id, advertiser_id)
  VALUES (auth.uid(), NEW.id);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER trigger_add_user_advertiser_mapping
AFTER INSERT ON advertisers
FOR EACH ROW
EXECUTE FUNCTION add_user_advertiser_mapping();

create policy "Allow logged-in read access" on public.campaigns
  for select using (auth.role() = 'authenticated');
create policy "Allow individual insert access" on public.campaigns
  for insert with check ((select auth.uid()) = created_by);
create policy "Allow individual update access" on public.campaigns
  for update using ((select auth.uid()) = created_by);
create policy "Allow individual delete access" on public.campaigns
  for delete using ((select auth.uid()) = created_by);
create policy "Allow logged-in read access" on public.ads
  for select using (auth.role() = 'authenticated');
create policy "Allow individual insert access" on public.ads
  for insert with check ((select auth.uid()) = created_by);
create policy "Allow individual update access" on public.ads
  for update using ((select auth.uid()) = created_by);
create policy "Allow individual delete access" on public.ads
  for delete using ((select auth.uid()) = created_by);


-- DUMMY DATA
