--
-- For use with https://github.com/supabase/supabase/tree/master/examples/slack-clone/nextjs-slack-clone

-- Custom types
create type public.app_permission as enum ('advertisers.delete', 'campaigns.delete');
create type public.app_role as enum ('admin', 'moderator', 'anonymous');
create type public.campaign_status as enum ('draft', 'active', 'paused', 'completed');
create type public.ad_status as enum ('active', 'paused', 'inactive');
create type public.interaction_type as enum ('impression', 'click');

-- USERS
create table public.users (
  id          uuid not null primary key, -- UUID from auth.users
  username    text
);
comment on table public.users is 'Profile data for each user.';
comment on column public.users.id is 'References the internal Supabase Auth user.';

-- Advertiser Table 
create table public.advertisers (
  id            bigint generated by default as identity primary key,
  created_at    timestamp default current_timestamp not null,
  name          text not null unique,
  owner_id      uuid references public.users not null
);
comment on table public.advertisers is 'A company or a person that runs advertisements.';

-- Campaign Table
create table public.campaigns (
  id              bigint generated by default as identity primary key,
  created_at      timestamp default current_timestamp not null,
  updated_at      timestamp default current_timestamp not null,
  name            text not null,
  budget          bigint not null check (budget >= 0), 
  start_date      timestamp not null,
  end_date        timestamp not null check (end_date >= start_date), 
  status          campaign_status default 'draft' not null,
  advertiser_id   bigint references public.advertisers on delete cascade not null
);
comment on table public.campaigns is 'Information about advertising campaigns.';

-- Ad Table
create table public.ads (
  id                bigint generated by default as identity primary key,
  campaign_id       bigint references public.campaigns on delete cascade not null, 
  title             text not null,
  description       text,
  image_url         text,
  landing_page_url  text not null,
  status            ad_status default 'active' not null,
  created_at        timestamp default current_timestamp not null,
  updated_at        timestamp default current_timestamp not null
);
comment on table public.ads is 'Advertisements running on a campaign.';

-- Impression Log Table
create table public.ad_interactions (
  id            bigint generated by default as identity primary key,
  ad_id         bigint references public.ads on delete cascade not null, 
  user_id       uuid references public.users not null,
  timestamp     timestamp default current_timestamp not null,
  status        interaction_type default 'impression' not null
);
comment on table public.ad_interactions is 'Record every instance where an ad is displayed to a user';

-- USER ROLES
create table public.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references public.users on delete cascade not null,
  role      app_role not null,
  unique (user_id, role)
);
comment on table public.user_roles is 'Application roles for each user.';

-- ROLE PERMISSIONS
create table public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';

-- authorize with role-based access control (RBAC)
create function public.authorize(
  requested_permission app_permission,
  user_id uuid
)
returns boolean as
$$
  declare
    bind_permissions int;
  begin
    select
      count(*)
    from public.role_permissions
    inner join public.user_roles on role_permissions.role = user_roles.role
    where
      role_permissions.permission = authorize.requested_permission and
      user_roles.user_id = authorize.user_id
    into bind_permissions;

    return bind_permissions > 0;
  end;
$$
language plpgsql security definer;

-- Secure the tables
alter table public.users
  enable row level security;
alter table public.advertisers
  enable row level security;
alter table public.campaigns
  enable row level security;
alter table public.ads
  enable row level security;
alter table public.ad_interactions
  enable row level security;
alter table public.user_roles
  enable row level security;
alter table public.role_permissions
  enable row level security;

-- inserts a row into public.users and assigns roles
create function public.handle_new_user()
returns trigger
set search_path = ''
as $$
  declare is_admin boolean;
  begin
    insert into public.users (id, username)
    values (new.id, new.email);

    select count(*) = 1 from auth.users into is_admin;

    if position('+supaadmin@' in new.email) > 0 then
      insert into public.user_roles (user_id, role) values (new.id, 'admin');
    elsif position('+supamod@' in new.email) > 0 then
      insert into public.user_roles (user_id, role) values (new.id, 'moderator');
    end if;

    return new;
  end;
$$ language plpgsql security definer;

-- trigger the function every time a user is created
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

/**
 * REALTIME SUBSCRIPTIONS
 * Only allow realtime listening on public tables.
 */

-- DUMMY DATA
